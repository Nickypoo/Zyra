<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MatchEntity.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">zyra</a> &gt; <a href="index.source.html" class="el_package">com.mingweisamuel.zyra.entity</a> &gt; <span class="el_source">MatchEntity.java</span></div><h1>MatchEntity.java</h1><pre class="source lang-java linenums">package com.mingweisamuel.zyra.entity;

import com.google.common.collect.Lists;
import com.mingweisamuel.zyra.enums.Region;
import com.mingweisamuel.zyra.enums.TeamId;
import com.mingweisamuel.zyra.match.Match;
import com.mingweisamuel.zyra.match.MatchFrame;
import com.mingweisamuel.zyra.match.MatchParticipantFrame;
import com.mingweisamuel.zyra.match.MatchTimeline;
import com.mingweisamuel.zyra.match.Participant;
import com.mingweisamuel.zyra.match.ParticipantIdentity;
import com.mingweisamuel.zyra.match.Player;
import com.mingweisamuel.zyra.match.TeamStats;
import com.mingweisamuel.zyra.util.LazyResetableFuture;

import java.util.ArrayList;
import java.util.List;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * A high-level representation of a match. Thread-safe.
 */
public class MatchEntity extends Entity {

    static MatchEntity create(EntityApi entityApi, Region region, long matchId) {
<span class="fc" id="L29">        return new MatchEntity(entityApi, region, matchId);</span>
    }

    /** This match's unique id. Set from initialization. */
    private final long matchId;

    /** The match's general information.  */
    private final LazyResetableFuture&lt;Match&gt; matchInfo;
    /** The match's timeline. */
    private final LazyResetableFuture&lt;MatchTimeline&gt; timeline;

    /** The match's participant entities. */
    private final LazyResetableFuture&lt;List&lt;ParticipantEntity&gt;&gt; participants;

    /** The match's team entities. */
    private final LazyResetableFuture&lt;List&lt;TeamEntity&gt;&gt; teams;

    private MatchEntity(EntityApi entityApi, Region region, long matchId) {
<span class="fc" id="L47">        super(entityApi, region);</span>
<span class="fc" id="L48">        this.matchId = matchId;</span>

<span class="fc" id="L50">        matchInfo = new LazyResetableFuture&lt;&gt;(() -&gt; entityApi.riotApi.matches.getMatchAsync(region, matchId));</span>
<span class="fc" id="L51">        timeline = new LazyResetableFuture&lt;&gt;(() -&gt; entityApi.riotApi.matches.getMatchTimelineAsync(region, matchId));</span>
<span class="fc" id="L52">        participants = matchInfo.thenApply(m -&gt; new ArrayList&lt;&gt;(Lists.transform(</span>
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">            m.participantIdentities, pid -&gt; new ParticipantEntity(</span>
<span class="pc" id="L54">                pid.participantId, m, pid.player != null ? entityApi.getSummonerFromPlayer(pid.player) : null))));</span>
<span class="fc" id="L55">        teams = matchInfo.thenApply(m -&gt; new ArrayList&lt;&gt;(Lists.transform(m.teams, TeamEntity::new)));</span>
<span class="fc" id="L56">    }</span>

    /** Returns the unique match id. Does not need to wait for any tasks to complete. */
    public long getMatchId() {
<span class="fc" id="L60">        return matchId;</span>
    }

    //region info methods
    public CompletableFuture&lt;Match&gt; getInfoAsync() {
<span class="fc" id="L65">        return matchInfo.get();</span>
    }
    public Match getInfo() {
<span class="fc" id="L68">        return matchInfo.join();</span>
    }
    //endregion

    //region timeline methods
    public CompletableFuture&lt;MatchTimeline&gt; getTimelineAsync() {
<span class="nc" id="L74">        return timeline.get();</span>
    }
    public MatchTimeline getTimeline() {
<span class="fc" id="L77">        return timeline.join();</span>
    }
    //endregion

    //region summoner methods
    public CompletableFuture&lt;List&lt;ParticipantEntity&gt;&gt; getParticipantsAsync() {
<span class="fc" id="L83">        return participants.get();</span>
    }
    public List&lt;ParticipantEntity&gt; getParticipants() {
<span class="fc" id="L86">        return participants.join();</span>
    }

    /**
     * Gets a CompletableFuture of the Participant corresponding to the given SummonerEntity. Will return {@code null}
     * if the summoner was not found. This may occur in unranked games where identity information is not available.
     * @param summonerEntity Summoner to find.
     * @return CompletableFuture of ParticipantEntity, or of {@code null} if not found.
     */
    public CompletableFuture&lt;ParticipantEntity&gt; getParticipantAsync(SummonerEntity summonerEntity) {
<span class="fc" id="L96">        return getParticipantsAsync().thenApply(l -&gt; l.stream().filter(</span>
<span class="fc" id="L97">            p -&gt; summonerEntity.equals(p.getSummonerEntity())).findAny().orElse(null));</span>
    }
    /**
     * Gets the Participant corresponding to the given SummonerEntity. Will return {@code null} if the summoner was
     * not found. This may occur in unranked games where identity information is not available.
     * @param summonerEntity Summoner to find.
     * @return ParticipantEntity, or {@code null} if not found.
     */
    public ParticipantEntity getParticipant(SummonerEntity summonerEntity) {
<span class="fc" id="L106">        return getParticipantAsync(summonerEntity).join();</span>
    }


    public CompletableFuture&lt;List&lt;TeamEntity&gt;&gt; getTeamsAsync() {
<span class="nc" id="L111">        return teams.get();</span>
    }
    public List&lt;TeamEntity&gt; getTeams() {
<span class="fc" id="L114">        return teams.join();</span>
    }
    //endregion

    //region TeamEntity
    /**
     * An entity representation of a team in a single match.
     */
    public class TeamEntity extends Entity {

        private final TeamStats teamStats;

<span class="fc" id="L126">        private TeamEntity(TeamStats teamStats) {</span>
<span class="fc" id="L127">            super(MatchEntity.this.entityApi, MatchEntity.this.region);</span>
<span class="fc" id="L128">            this.teamStats = teamStats;</span>
<span class="fc" id="L129">        }</span>

        public int getTeamId() {
<span class="fc" id="L132">            return teamStats.teamId;</span>
        }

        public TeamStats getTeamStats() {
<span class="nc" id="L136">            return teamStats;</span>
        }

        public boolean isWinner() {
<span class="fc" id="L140">            return TeamId.WIN.equals(teamStats.win);</span>
        }

        public List&lt;ParticipantEntity&gt; getParticipants() {
<span class="nc" id="L144">            return MatchEntity.this.getParticipants().stream()</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">                .filter(p -&gt; this.getTeamId() == p.getTeamId()).collect(Collectors.toList());</span>
        }
    }
    //endregion

    //region ParticipantEntity
    /**
     * A entity representation of a participantInfo in a single match. May or may not be associated with a SummonerEntity.
     */
    public class ParticipantEntity extends Entity {

        private final int participantId;
        private final SummonerEntity summonerEntity;

        private final Participant participantInfo;

        private final LazyResetableFuture&lt;SortedMap&lt;Long, MatchParticipantFrame&gt;&gt; timeline;

        /**
         * Creates a participant entity.
         * @param participantId The participant id. Required.
         * @param matchInfo Match information. Calling {@code MatchEntity.this.matchInfo.join()} will deadlock.
         * @param summonerEntity Summoner entity, can be null if {@link ParticipantIdentity#player} not provided by api.
         */
<span class="fc" id="L169">        private ParticipantEntity(int participantId, Match matchInfo, SummonerEntity summonerEntity) {</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">            super(MatchEntity.this.entityApi, summonerEntity == null ? MatchEntity.this.region : summonerEntity.region);</span>

<span class="fc" id="L172">            this.participantId = participantId;</span>
<span class="fc" id="L173">            this.summonerEntity = summonerEntity;</span>

            // doesn't need async because getInfo() must already have been pulled.
<span class="fc" id="L176">            this.participantInfo = matchInfo.participants.stream()</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">                .filter(p -&gt; this.participantId == p.participantId).findAny()</span>
<span class="pc" id="L178">                .orElseThrow(() -&gt; new IllegalStateException(&quot;Participant with id not found: &quot; + participantId));</span>

            //noinspection ConstantConditions
<span class="fc" id="L181">            this.timeline = MatchEntity.this.timeline</span>
<span class="fc" id="L182">                .thenApply(timeline -&gt; {</span>
<span class="fc" id="L183">                    SortedMap&lt;Long, MatchParticipantFrame&gt; result = new TreeMap&lt;&gt;();</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                    for (MatchFrame frame : timeline.frames)</span>
<span class="fc" id="L185">                        result.put(frame.timestamp, frame.participantFrames.get(participantId));</span>
<span class="fc" id="L186">                    return result;</span>
                });
<span class="fc" id="L188">        }</span>

        /** @return The participant's unique id for the match. */
        public int getParticipantId() {
<span class="fc" id="L192">            return participantId;</span>
        }

        /**
         * Gets the summoner entity who played as this participantInfo.&lt;br&gt;&lt;br&gt;
         *
         * May return cached SummonerEntity instance as described in {@link EntityApi#getSummonerFromPlayer(Player)}.
         *
         * @return The summoner entity. May be {@code null} if summoner entity doesn't exist. This occurs when
         *      matches do not include identity information which usually means the match was unranked.
         */
        public SummonerEntity getSummonerEntity() {
<span class="fc" id="L204">            return summonerEntity;</span>
        }

        /** @return The participant information. */
        public Participant getParticipantInfo() {
<span class="fc" id="L209">            return participantInfo;</span>
        }
        /** @return The participant's teamId. See {@link com.mingweisamuel.zyra.enums.TeamId}. */
        public int getTeamId() {
<span class="fc" id="L213">            return participantInfo.teamId;</span>
        }
        /** @return The participant's TeamEntity. */
        public TeamEntity getTeam() {
<span class="fc" id="L217">            return MatchEntity.this.getTeams().stream()</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">                .filter(t -&gt; this.getTeamId() == t.getTeamId()).findAny().orElse(null);</span>
        }

        /**
         * @return A CompletableFuture for this participant's timeline, which is a map from timestamps (long) to
         * MatchParticipantFrames. The map is sorted in chronological order (ascending timestamps).
         */
        public CompletableFuture&lt;SortedMap&lt;Long, MatchParticipantFrame&gt;&gt; getTimelineAsync() {
<span class="nc" id="L226">            return timeline.get();</span>
        }
        /**
         * @return This participant's timeline, which is a map from timestamps (long) to MatchParticipantFrames.
         * The map is sorted in chronological order (ascending timestamps).&lt;br&gt;
         * May block while waiting for data.
         */
        public SortedMap&lt;Long, MatchParticipantFrame&gt; getTimeline() {
<span class="fc" id="L234">            return timeline.join();</span>
        }
    }
    //endregion

    //region equals hashCode
    /**
     * Returns true if this MatchEntity has the same match ID and is from the same region as OTHER.
     * @param other Object to compare to.
     * @return True if equal.
     */
    @Override
    public boolean equals(Object other) {
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (this == other) return true;</span>
<span class="nc bnc" id="L248" title="All 4 branches missed.">        if (other == null || getClass() != other.getClass()) return false;</span>

<span class="nc" id="L250">        MatchEntity that = (MatchEntity) other;</span>

<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (matchId != that.matchId) return false;</span>
<span class="nc" id="L253">        return region.equals(that.region);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L258">        int result = (int) (matchId ^ (matchId &gt;&gt;&gt; 32));</span>
<span class="nc" id="L259">        result = 31 * result + region.hashCode();</span>
<span class="nc" id="L260">        return result;</span>
    }
    //endregion
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>